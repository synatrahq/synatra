---
title: Subagents
description: Hierarchical agent delegation for complex tasks.
---

Subagents enable hierarchical task delegation, allowing a parent agent to delegate subtasks to specialized child agents. This creates a tree of execution where each agent focuses on its area of expertise.

## Overview

A Subagent configuration defines:

- **Which agent** can be delegated to
- **What alias** the parent uses to refer to it
- **What description** helps the parent understand when to delegate
- **Which version** of the agent to use

## Configuration Example

```json
{
  "subagents": [
    {
      "agent": "Data Analyst",
      "alias": "data_analyst",
      "description": "Specializes in SQL queries and data analysis",
      "versionMode": "current"
    },
    {
      "agent": "Code Reviewer",
      "alias": "code_reviewer",
      "description": "Reviews code for bugs and best practices",
      "versionMode": "fixed"
    }
  ]
}
```

## Delegation Tools

When subagents are configured, the parent agent receives delegation tools:

```
delegate_to_{alias}(task: string, dependsOn?: array)
```

For the example above, the parent would have:

- `delegate_to_data_analyst`
- `delegate_to_code_reviewer`

## Execution Model

```
Thread
├── Run (Parent Agent)
│   ├── delegate_to_data_analyst("Analyze sales data")
│   │   └── Run (Data Analyst)
│   │       └── ... subagent execution ...
│   │       └── return_to_parent({ analysis: ... })
│   │
│   └── delegate_to_code_reviewer("Review the query")
│       └── Run (Code Reviewer)
│           └── ... subagent execution ...
│           └── return_to_parent({ issues: [...] })
```

### Parent-Child Relationship

| Entity     | Role                                  |
| ---------- | ------------------------------------- |
| Parent Run | Coordinates and delegates tasks       |
| Child Run  | Executes delegated task independently |

When a parent delegates:

1. Parent status → Waiting for subagent
2. Child run created
3. Child executes independently
4. Child completes → parent resumes

## Dependencies

Subagents can depend on results from sibling subagents:

```javascript
delegate_to_code_reviewer({
  task: "Review the SQL query generated by data_analyst",
  dependsOn: [{ alias: "data_analyst", summary: "The generated SQL query" }],
})
```

When a subagent has dependencies:

1. Previous results are collected from the conversation history
2. Dependency context is formatted and prepended to the task
3. The subagent sees what related agents have already done

## Subagent Context

Subagents receive additional context:

### Previous Results

```markdown
## Previous Results from Related Subagents

### data_analyst

**Task:** Analyze sales data
**Result:**
{ "query": "SELECT ...", "rows": 1234 }
```

### Sibling Awareness

```markdown
## Other Available Agents (via parent)

If your task requires capabilities outside your scope, call `return_to_parent` with a suggestion to delegate to an appropriate agent:

- **code_reviewer**: Reviews code for bugs and best practices
```

## Returning Results

Subagents use `return_to_parent` to complete their task:

```javascript
return_to_parent({
  result: {
    analysis: "Sales increased by 15%",
    data: [...]
  }
})
```

This is different from `task_complete`:

- `return_to_parent`: Returns result to parent agent, parent continues
- `task_complete`: Ends the entire thread with a summary

## Version Modes

| Mode    | Behavior                         |
| ------- | -------------------------------- |
| Current | Use latest release of subagent   |
| Fixed   | Lock to specific release version |

Use fixed mode when:

- You need reproducible behavior
- The parent depends on specific subagent capabilities
- You want to test parent changes without subagent changes

## Human-in-the-Loop

Subagents inherit the same human-in-the-loop capabilities:

- Tool approval requests bubble up to the thread
- Users can approve/reject actions from any level
- The entire thread waits during approval

## Best Practices

1. **Specialize subagents**: Each subagent should have a focused purpose
2. **Write clear descriptions**: Help the parent understand when to delegate
3. **Use dependencies wisely**: Pass context between related subagents
4. **Monitor depth**: Avoid deeply nested delegation
5. **Handle failures**: Parent should gracefully handle subagent failures
6. **Version strategically**: Use fixed versions for production stability

## Example: Research Assistant

```
Research Assistant (Parent)
├── Subagent: web_searcher
│   └── "Searches the web for relevant information"
├── Subagent: summarizer
│   └── "Summarizes long documents and articles"
└── Subagent: fact_checker
    └── "Verifies claims against reliable sources"
```

Workflow:

1. User asks: "Research the latest AI developments"
2. Parent delegates to `web_searcher`
3. Parent delegates to `summarizer` with dependency on search results
4. Parent delegates to `fact_checker` with dependency on summary
5. Parent synthesizes all results and responds
