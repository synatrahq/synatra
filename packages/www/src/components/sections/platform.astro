---
import { PhShieldCheck, PhLock, PhDatabase, PhArrowsClockwise, PhSparkle, PhCode } from "phosphor-icons-astro"
---

<section id="platform-section" class="border-t border-surface-border-muted px-6 py-20 grid-dots">
  <div class="mx-auto max-w-5xl">
    <p class="text-xs font-medium text-gray-500">Production ready</p>
    <h2 class="mt-4 max-w-2xl text-2xl font-semibold tracking-tight text-white md:text-3xl">
      Built for developers. Ready for enterprise.
    </h2>
    <div class="mt-10 grid gap-px overflow-hidden rounded-lg border border-surface-border-muted bg-surface-border/50 sm:grid-cols-2 lg:grid-cols-3">
      <article class="bg-surface-bg-muted p-6">
        <div class="flex h-9 w-9 items-center justify-center rounded-lg bg-surface-bg-elevated text-gray-400">
          <PhShieldCheck class="h-4 w-4" />
        </div>
        <h3 class="mt-4 text-sm font-medium text-white">Approval workflows</h3>
        <p class="mt-2 text-xs leading-relaxed text-gray-500">
          Pause execution until a human approves. Configure per-tool: owner only, any member, or self-approval. Modify parameters before proceeding.
        </p>
      </article>
      <article class="bg-surface-bg-muted p-6">
        <div class="flex h-9 w-9 items-center justify-center rounded-lg bg-surface-bg-elevated text-gray-400">
          <PhLock class="h-4 w-4" />
        </div>
        <h3 class="mt-4 text-sm font-medium text-white">Fine-grained permissions</h3>
        <p class="mt-2 text-xs leading-relaxed text-gray-500">
          Role-based access control at the tool level. Define who can run what, and which operations require approval.
        </p>
      </article>
      <article class="bg-surface-bg-muted p-6">
        <div class="flex h-9 w-9 items-center justify-center rounded-lg bg-surface-bg-elevated text-gray-400">
          <PhDatabase class="h-4 w-4" />
        </div>
        <h3 class="mt-4 text-sm font-medium text-white">Secure database access</h3>
        <p class="mt-2 text-xs leading-relaxed text-gray-500">
          Connect Postgres and MySQL from your VPC. Deploy a lightweight connector, outbound-only. No firewall changes, no exposed ports.
        </p>
      </article>
      <article class="bg-surface-bg-muted p-6">
        <div class="flex h-9 w-9 items-center justify-center rounded-lg bg-surface-bg-elevated text-gray-400">
          <PhArrowsClockwise class="h-4 w-4" />
        </div>
        <h3 class="mt-4 text-sm font-medium text-white">Durable execution</h3>
        <p class="mt-2 text-xs leading-relaxed text-gray-500">
          Workflows survive restarts, deploys, and outages. State recovery is automatic. Long-running tasks handled gracefully.
        </p>
      </article>
      <article class="bg-surface-bg-muted p-6">
        <div class="flex h-9 w-9 items-center justify-center rounded-lg bg-surface-bg-elevated text-gray-400">
          <PhSparkle class="h-4 w-4" />
        </div>
        <h3 class="mt-4 text-sm font-medium text-white">Multi-LLM</h3>
        <p class="mt-2 text-xs leading-relaxed text-gray-500">
          OpenAI, Anthropic, Google. Use the right model for each agent. Switch providers without changing your tools.
        </p>
      </article>
      <article id="vim-card" class="vim-card relative bg-surface-bg-muted p-6 cursor-pointer overflow-hidden group">
        <div class="vim-content transition-opacity duration-300">
          <div class="flex h-9 w-9 items-center justify-center rounded-lg bg-surface-bg-elevated text-gray-400">
            <PhCode class="h-4 w-4" />
          </div>
          <h3 class="mt-4 text-sm font-medium text-white">Vim mode</h3>
          <p class="mt-2 text-xs leading-relaxed text-gray-500">
            Full Vim keybindings in the code editor. Because real developers don't use mice. Escape to normal mode, you know the rest.
          </p>
        </div>
        <div class="vim-terminal absolute inset-0 flex flex-col bg-gray-950 p-3 opacity-0 transition-opacity duration-300">
          <div class="flex items-center gap-1.5 mb-2">
            <div class="h-2 w-2 rounded-full bg-red-500"></div>
            <div class="h-2 w-2 rounded-full bg-yellow-500"></div>
            <div class="h-2 w-2 rounded-full bg-green-500"></div>
            <span class="ml-2 text-[10px] text-gray-500">vim</span>
          </div>
          <div class="flex-1 font-mono text-[11px] leading-relaxed overflow-hidden">
            <div class="vim-line text-gray-400">~</div>
            <div class="vim-line text-gray-400">~</div>
            <div class="vim-line text-white vim-cmd"></div>
          </div>
          <div class="vim-status mt-1 text-[10px] text-red-400 font-mono h-4"></div>
        </div>
      </article>
    </div>
  </div>
</section>

<style>
  .vim-card:hover .vim-content,
  .vim-card.is-playing .vim-content {
    opacity: 0;
  }

  .vim-card:hover .vim-terminal,
  .vim-card.is-playing .vim-terminal {
    opacity: 1;
  }

  .vim-cursor {
    display: inline-block;
    width: 7px;
    height: 14px;
    background: #a1a1aa;
    animation: blink 1s step-end infinite;
    vertical-align: text-bottom;
    margin-left: 1px;
  }

  @keyframes blink {
    50% { opacity: 0; }
  }

  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    20% { transform: translateX(-2px); }
    40% { transform: translateX(2px); }
    60% { transform: translateX(-2px); }
    80% { transform: translateX(1px); }
  }

  .vim-shake {
    animation: shake 0.3s ease-in-out;
  }

  @media (prefers-reduced-motion: reduce) {
    .vim-cursor {
      animation: none;
      opacity: 1;
    }
    .vim-shake {
      animation: none;
    }
  }
</style>

<script>
  const vimCard = document.getElementById("vim-card")
  if (vimCard && !window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
    const cmdEl = vimCard.querySelector(".vim-cmd") as HTMLElement
    const statusEl = vimCard.querySelector(".vim-status") as HTMLElement
    const terminalEl = vimCard.querySelector(".vim-terminal") as HTMLElement

    const sequence = [
      { cmd: ":q", error: "E37: No write since last change", delay: 600 },
      { cmd: ":exit", error: "E492: Not an editor command: exit", delay: 500 },
      { cmd: ":quit", error: "E37: No write since last change", delay: 500 },
      { cmd: "^C", error: "Type :q! to quit without saving", delay: 400 },
      { cmd: ":q!", error: null, delay: 500 },
    ]

    let isPlaying = false
    let timeoutId: number | null = null

    const typeText = (el: HTMLElement, text: string, callback: () => void) => {
      let i = 0
      el.innerHTML = '<span class="vim-cursor"></span>'
      const type = () => {
        if (i < text.length) {
          el.innerHTML = text.slice(0, i + 1) + '<span class="vim-cursor"></span>'
          i++
          setTimeout(type, 50 + Math.random() * 50)
        } else {
          callback()
        }
      }
      type()
    }

    const playSequence = async () => {
      if (isPlaying) return
      isPlaying = true
      vimCard.classList.add("is-playing")

      for (let i = 0; i < sequence.length; i++) {
        const step = sequence[i]
        await new Promise<void>((resolve) => {
          typeText(cmdEl, step.cmd, () => {
            setTimeout(() => {
              if (step.error) {
                statusEl.textContent = step.error
                terminalEl.classList.add("vim-shake")
                setTimeout(() => terminalEl.classList.remove("vim-shake"), 300)
              } else {
                statusEl.innerHTML = '<span class="text-emerald-400">Finally! ðŸŽ‰</span>'
              }
              setTimeout(resolve, step.delay)
            }, 200)
          })
        })
        statusEl.textContent = ""
      }

      timeoutId = window.setTimeout(() => {
        isPlaying = false
        vimCard.classList.remove("is-playing")
        cmdEl.innerHTML = ""
        statusEl.textContent = ""
      }, 1500)
    }

    vimCard.addEventListener("mouseenter", () => {
      if (timeoutId) clearTimeout(timeoutId)
      playSequence()
    })

    vimCard.addEventListener("click", () => {
      if (timeoutId) clearTimeout(timeoutId)
      isPlaying = false
      cmdEl.innerHTML = ""
      statusEl.textContent = ""
      playSequence()
    })
  }
</script>
